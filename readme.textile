h1. An Introduction to Enlive

Though Enlive has been around for sometime now the Clojure community has been slow to embrace this useful library. I believe this is due simply to the lack of good introductory documentation based on real examples. Please let me know if you find this tutorial useful or helpful in any way. Feel free to suggest additions, corrections, and improvements (even better fork the repo and send me a patch).

h2. What You need to Know

Not much. This tutorial assumes little about your exposure to Clojure. At the very least you'll need to have the Java Virtual Machine (JVM) installed. I won't go into great detail about Clojure's features but I'll try to explain any concepts which may impede your understanding of Enlive's functionality.

As the tutorials progress they will be more useful to you if you have some experience with a modern webframework that ships with a HTML templating library. If you do know Clojure the tutorials are fairly amenable to skimming. My only real assumption is that you have some experience at the command line.

h2. HTML Templating

There are two real camps in HTML templating. The first which almost everyone is familiar with is the PHP style template:

<pre>
<?php
for($i = 0; $i < $len; $i++) {
?><p>Foo <?echo $i?></p><?
}
?>
</pre>

This is of course enough to drive anyone insane and some templating frameworks like Django have made marginal improvements:

<pre>
{% for i in foo %}
<p>Foo {{ i }}</p>
{% endfor %}
</pre>

This is a bit easier on the eyes. But this isn't very composable and you're stuck with a limited subset of your programming language. By not composable I mean that building pages is largely a copy and paste affair even when templating solutions support inheritance.

This has driven many programmers to discard templating DSLs and to generate markup directly in code. While this is fast and flexible as you now have the power of function composition, it also means that you're putting quite a bit of distance between yourself and a designer comfortable writing HTML and CSS.

There are a few existing solutions that have a novel approach to this problem such as "Pure":http://beebole.com/pure/.

Which brings us to Enlive. Enlive gives you the advantages of designer accessibe templates (since they're just HTML) without losing the power of fuction composition.

h2. Why Enlive?

Enlive presents a different appraoch from the more popular templating solutions:

** Code and markup are completely separate.
** You get to use CSS like syntax to manipulate HTML.
** Template inheritance isn't some fancy trick, it just function composition.
** You have access to the full power of Clojure to manipulate your templates (yes, macros!).

When working with the standard templating solutions you generally need to answer one of two question. Either "What type of text am I going to generate?" or "What type of HTML emitting functions should I write?"

With Enlive you generally need to approach templating in two steps:

# What selectors match the part of the HTML document that I care about?
# What templates and snippets do I need write?

h2. What We'll Cover

There are six examples in total.

The first one covers grabbing the headlines and points from Hackers News. The next one shows how to make the code less redundant. The third scrapes the New York Times front page since that presents more challenges than Hacker News. The fourth example shows how to use Compojure and Enlive together. The fifth example shows how things like looping are achieved without writing any code into the markup. The sixth example shows that Enlive can do all the fancy template inheritance magic you might be used to if you're coming from Django or some other popular modern webframework.

h2. Clone This Repo

The usual:

<pre class="console">
git clone git://github.com/swannodette/enlive-tutorial.git
</pre>

h2. Install Leiningen

In order to start playing around as fast possible you should use Leiningen. Leiningen is the easy_install (Python) and gems (Ruby) of the Clojure world. Phil Hagelberg and Co. have done a considerable amount of excellent work to make dependency management simple. I truly envy the new Clojurians who do not know the dark times before *lien repl* and *lein swank* :)

Once you have Leiningen installed, switch into this repository's directory. From there run the following command:

<pre class="console">
lein deps
</pre>

This will install all of the dependencies required for getting through the tutorial. This might take a minute and and will probably generate <i>a lot</i> of ouptut. While this may seem disconcerting, this means you'll have a fully functioning Clojure setup with needing to bother with installing Emacs or an IDE. Once the the dependencies are installed enter the following command at your terminal:

<pre class="console">
lein repl
</pre>

This will launch a Clojure REPL (Read-Eval-Print-Loop) that has the classpath set properly. Be very thankful if you don't know what the last sentence means. Managing the classpath is one of the few real annoyances when programming Clojure and it's largely Java's fault.

h2. Your First Scrape with Enlive - Hacker News

Enlive is fantastic for scraping the content of webpages. It allows you to scrape content by using a syntax very similar to CSS selectors. In the REPL type the following lines (note that *user=>* is the REPL prompt, not something you type in):

<pre class="console">
user=> (ns tutorial.scrape1)
nil
tutorial.scrape1=> (load "scrape1")
nil
tutorial.scrape1=> *base-url*
"http://news.ycombinator.com/"
</pre>

The first line puts us into a namespace. Note that the REPL prompt reflects this. By switching into the tutorial namespace we can use functions defined in the tutorial without having to qualify them. It's much easier to type <code>*base-url*</code> then <code>tutorial.scrape1/*base-url*</code>. In the next line we load the first tutorial into the REPL. Unlike many scripting languages, loading a file actually <i>compiles</i> it. Clojure is not interpreted.

Let's see what's in that file. Open up *scrape1.clj* with your favorite text editor (you can find it in *your-tutorial-clone/src/tutorial/*). You'll see it's a fairly short program. 

At the top of this file is the namespace declaration. This keeps your code from clashing with other people's code when they try to use your library. The namespace declaration also includes another library, Enlive, via <code>:require</code>. In this case we are generating an alias so we don't have to type the very long namespace for Enlive.

The function <code>fetch-url</code> grabs the contexts of a url synchronously. <code>fetch-url</code> uses <code>html/html-resource</code> (remember we aliased *net.cgrand.enlive-html* to *html* for convenience) another handy function defined in the Enlive library. It takes raw HTML and converts it into a nested data structure (think DOM minus tediousness).

Note that the function <code>hn-headlines</code> uses <code>fetch-url</code>. But it's also surrounded by a lot of funny stuff. You might have noticed <code>html/select</code>; <code>html/select</code> takes parsed html content and selects the nodes specified by a Clojure vector that looks very similar to a CSS selector. 

<pre>
[:td.title :a]
</pre>

Now that looks kind of weird. But if you squint a little it might remind you of this:

<pre>
td.title a
</pre>

This is a CSS selector for matching all links inside of table elements that have the CSS class "title". If you're a Javascript hacker you should know this stuff by heart.

So let's break this down. <code>fetch-url</code> grabs the contents of the url and parses it into a data structure. <code>html/select</code> takes it and extracts only those nodes that match the selector - it always returns a vector of nodes. We then use Clojure's <code>map</code> function to interate over the vector's elements applying a function to extract each nodes' text-node, in this case <code>html/text</code> (<code>map</code> is actually lazy, but we're not going to get into what that means in this Enlive tutorial).

Believe it or not, these 10 lines of code are enough to extract all of the headlines from the Hacker News front page. Let's try it out at the REPL now.

<pre class="console">
tutorial.scrape1=> (hn-headlines)
("A 'lorem ipsum' for images." "Google Reader Can Now Track Changes to Any Website - Even Without a Feed" "jQuery 1.4.1 Released" ... "More")
</pre>

Nice. After this the next function <code>hn-points</code> should make a lot more sense. It does the same thing but we grab the score from a different place in the markup. Try to run this function as well.

<pre class="console">
tutorial.scrape1=> (hn-points)
... output ...
</pre>

The last function takes the output of the two different functions and prints out the headline and score for each item on Hackers News. 

<pre class="console">
tutorial.scrape1=> (print-headlines-and-points)
... output ...
</pre>

*print-hn-headlines-and-points* looks like a doozy doesn't it?

<pre>
(defn print-headlines-and-points []
  (doseq [line (map #(str %1 " (" %2 ")") (hn-headlines) (hn-points))]
    (println line)))
</pre>

Let's break it down. Again we have <code>map</code>. We know that it maps a function over a vector to return a new vector of elemenets with that fuction applied.

<pre>
#(str %1 " (" %2 ")") ; is just shorthand for
(fn [arg1 arg2] (str arg1 " (" arg2 ")")
</pre>

This is an anonymous function. I'm not going to explain that here, they're pretty popular these days. <code>str</code> is built in function for doing string concatenation.

Oddly this <code>map</code> is accepting not one list of things, but two! Check this out:

<pre class="console">
tutorial.scrape1=> (map + [1 2 3] [4 5 6])
(5 7 9)
</pre>

Wow you can map two different vectors into one! Finally we have <code>doseq</code>. <code>doseq</code> is just a convenient way to work with lists when you're dealing with *side effects* like printing to the REPL. I'm not going to get into that here. All it does is say take list of things, assign each thing one at time to a variable, and then execute the following expression (hopefully you're actually doing something with that variable!

Not bad for 17 lines of code. One obvious problem here is that we make two separate requests for the Hacker News front page. Let's fix this now.

h2. Your Second Scrape - Improvements

Take a look at scrape2.clj. It's also about 17 lines of code and it looks pretty much the same except that we not longer have one function to grab headlines and another for article points.

<pre>
(defn hn-headlines-and-points []
  (map html/text
       (html/select (fetch-url *base-url*)
                    #{[:td.title :a] [:td.subtext first-child]})))
</pre>

This select grabs what we're interested at the same time.

<pre>
#{[:td.title :a] [:td.subtext first-child]}
</pre>

Is pretty much the same as:

<pre>
td.title a, td.subtext:first-child
</pre>

Let try out the functions. Start up the repl with *lein repl* if you've shut it down and run the following.

<pre class="console">
tutorial.scrape1=> (ns tutorial.scrape2)
nil
tutorial.scrape2=> (load "scrape2")
nil
tutorial.scrape2=> (hn-headlines-and-points)
... output ...
</pre>

The results are interleaved, so we can use Clojure's partition function to pair them up and output them just like we did in the previous scrape. The map looks a little bit different:

<pre>
(defn print-headlines-and-points []
  (doseq [line (map (fn [[h s]] (str h " (" s ")"))
                    (partition 2 (hn-headlines-and-points)))]
    (println line)))
</pre>

To get a sense of what partition does let's use the REPL again:

<pre class="console">
tutorial.scrape2=> (partition 2 [1 2 3 4 5 6 7 8 9 0])
((1 2) (3 4) (5 6) (7 8) (9 0))
</pre>

Neat it lets us pair things together. Exactly what we need.

Man, but what's up with the *fn* this time?

<pre>
(fn [[h s]] (str h " (" s ")"))
</pre>

Say hello to destructuring. A lot of popular languages allow you to destructure but probably not as ubiquitously as Clojure does. Here we know that we are going to receive a two element vector for each item in the vector we're mapping over. So we're just saying we to assign the first element of that pair to the local variable h and the other to v.

The rest of the function should be clear from the last tutorial.

h2. Your Third Scrape - The New York Times

By now you should feel like a pro. The third one, scrape3.clj tackles something considerably more difficult. Now to be clear this not that useful since the New York Times provides a fairly comprehensive list of RSS feeds. But the structure of the New Yorks Times page forces us to think about how to best leverage Enlive's abilities.

Take a look at *scrape3.clj*. This is considerable longer. Before we dive in let's see how it works. Start up the Clojure REPL if it's not already up and running.

<pre>
tutorial.scrape2=> (ns tutorial.scrape3)
nil
tutorial.scrape3=> (laod "scrape3")
nil
tutorial.scrape3=> (print-stories)
... output ...
</pre>

Now this isn't perfect for a variety of reason but it work well enough for the purposes of demonstration. Let's look at the code. At the top of the file we see that we have a variety of selectors.

<pre>
(def *story-selector*
     (html/selector [[:div.story
                      (html/but :.advertisement)
                      (html/but :.autosStory)
                      (html/but :.adCreative)]]))
</pre>

Here we are matching any div with the CSS class story that does not also have any of the other classes specified.

<pre>
(def *headline-selector*
     (html/selector #{[html/root :> :h2 :a],
                      [html/root :> :h3 :a]
                      [html/root :> :h5 :a]}))
</pre>

Here we know from looking at the markup of the page that headlines might match any of these three selectors. The selectors will only match headline tags that are children of the root element. We do this because there are story divs on the New York Times webpage that actually have multiple headlines underneath. The byline and story summary selectors are pretty much the same.

<pre>
(defn extract [node]
  (let [headline (first (html/select [node] *headline-selector*))
        byline   (first (html/select [node] *byline-selector*))
        summary  (first (html/select [node] *summary-selector*))
        result   (map html/text [headline byline summary])]
    (zipmap [:headline :byline :summary] (map #(re-gsub #"\n" "" %) result))))
</pre>

Here we take a node and extract the match. Note that we have to call first on the result of *html/select* because *html/select* always returns a sequence of nodes and not a single node. *zipmap* is a handy function, it allows us to take two sequences and zip them up into a hash-map. So after extract only the text nodes of the matches and removing any newline characters we zip it up into a tidy hash-map.

Because this scrape is not comprehensive we might match empty stories, so define a function *empty-story?* that checks for that. Hopefully by this point you can begin to make sense of the last three functions.

So that's it for scraping. It's time to move onto how Enlive is useful for building your own pages.

h2. Your First Template - The Basics

This is where things begin to get really interesting. We're going to use Compojure, and ultralight http framework. If you're familiar with Rack or CherryPy you will feel right at home.

Let's get started. If you aren't running a repl be sure to start one up from the repo directory with *lein repl*.

Once you see the REPL prompt type the following:

<pre>
tutorial.scrape3=> (ns tutorial.template1)
nil
tutorial.template1=> (load "template1")
nil
tutorial.template1 => (start-app)
</pre>

You should see some output that lets you know that Compojure is starting up a webserver on port 8080. Point your browser at *http://localhost:8080*. You should see a very boring page. Point your browser at *http://localhost:8080/change*. You should see something slightly different.

First open template1.html and take a look at it. If you're used to other templating solutions the most shocking thing should be that there absolutely no Clojure code in this file. And there never will be. Period.

Now let's take a look at the code. By now the namespace part should be familiar so we'll skip over that. After the ns declaration we'll see our first template definition:

<pre>
(html/deftemplate index "tutorial/template1.html"
  [ctxt]
  [:p#message] (html/content (:message ctxt)))
</pre>

Every template has the argument list [name source args & forms]. An Enlive template is a macro that when compiled will create a function with the same name. This function will have the same signature as defined by *args*. *forms* consists of pairs of Enlive selectors and a function to execute for each node that matches the selector.

Here our template will find all *p* elements with the CSS id *message*. CSS ids should be unique so ideal this will only match a single element. Then we have the function which will receive this matching element.

<pre>
(html/content (:message ctxt))
</pre>

This means we'll replace the content of any matching node with the value for the key *:message* in the ctxt hash-map. The important thing to grasp here is that *html/content* is a function which <i>returns</i> a function which will receive the matched element.

For example what if we wanted to include a message if there is no value for *:message* in *ctxt*? It would look something like this:

<pre>
(html/deftemplate index "tutorial/template1.html"
  [ctxt]
  [:p#message] (fn [match]
                 (if-let [msg (:message ctxt)]
                   ((html/content msg) match)
                   ((html/content "Nothing to see here!") match))))
</pre>

It should be clear here that *html/content* returns a function which will receive the matching element and modify it. This could be made slightly less verbose like so:

<pre>
(html/deftemplate index "tutorial/template1.html"
  [ctxt]
  [:p#message] #(if-let [msg (or (:message ctxt)
                                 "Nothing to see here!")]
                  ((html/content msg) %)))
</pre>

But even this is kinda meh. While Enlive does not have a great shortcut for expressing this pattern it's easy to write macros (we'll get to those later. But watch out it's an advanced topic). I've included a handy macro called *maybe-content* which allows to write something like this:

<pre>
(html/deftemplate index "tutorial/template1.html"
  [ctxt]
  [:p#message] (maybe-content (:message ctxt)
                              "Nothing to set here!"))
</pre>

Pretty slick eh? ;) This is just touching the tip of the iceberg.

The remainder of *template1.clj* is really specific to Compojure. We're not going to get too deep into that here because these tutorials are about Enlive, not Compojure.

<pre>
(defroutes example-routes
  (GET "/"
       (render (index {})))
  (GET "/change"
       (render (index {:message "We changed the message!"})))
  (ANY "*"
       [404 "Page Not Found"]))
</pre>

This is simply the route defining syntax. It should relatively familiar to the working web developer especially if you have experience with any modern web framework. A couple things to note *render* is not a function of Enlive, it's something I added via *utils.clj* in the repo. *render* isn't magic it's just a function that looks like this:

<pre>
(defn render [t]
  (apply str t))
</pre>

All this does is take a list of strings and concatenate them into one large string. This is because when an Enlive template function is called it returns a list of strings.

Also note that our template function *index* must be called with at least one parameter. That's because Enlive templates are just normal Clojure functions and there's no such thing as optional parameters in Clojure. It's quite simple to add that functionality via macros but it's just not worth getting into here. The last bit of *template1.clj* is just Compojure boilerplate for starting and stopping the server.

Well that's about it! You've seen your first Enlive template. While it may not seem like much yet, <i>*there was absolutely no mixing of code and HTML*</i>. If you bear with me till the third template tutorial, I think you'll see some truly amazing repercussions from this fact.

h2. Your Second Template - Looping

One of the things you use all the time when generating web pages is looping over some piece of HTML because you need to present a list of things to the user. People just love lists. How can Enlive create lists of HTML when there's no code in the template?! We'll get into this in this tutorial.

If you don't have a Clojure REPL running start a new one with *lein repl* at the commandline from the tutorial repo's directory. Enter the following (if you're continuing from the previous tutorial you should should stop the Compojure app for that tutorial first):

<pre class="console">
tutorial.template1=> (stop-app)
nil
tutorial.template1=> (ns tutorial.template2)
nil
tutorial.template2=> (load "template2")
nil
tutorial.template2=> (start-app)
... output ...
</pre>

Open up the file *template2.html* in your text editor and give it a quick look over. Then open the file *template2.html* in your favorite web browser. It's just page with a list of links, not that special. Point your browser at *http://localhost:8080/*. You should see pretty much the same thing except that we've dynamically inserted links.

How did we do that if we have no inline code to define the loop? Let's get into the code. Open up *template2.clj* in your favorite text editor. At the top of the file you should see the by now familiar namespace declaration. After that we declare a variable for holding a dummy context which we're going to pass to our template.

<pre>
(def *dummy-context*
     {:title "Enlive Template2 Tutorial"
      :sections [{:title "Clojure"
                  :links [{:text "Macros"
                           :href "http://www.clojure.org/macros"}
                          {:text "Multimethods & Hierarchies"
                           :href "http://www.clojure.org/multimethods"}]}
                 {:title "Compojure"
                  :links [{:text "Requests"
                           :href "http://www.compojure.org/docs/requests"}
                          {:text "Middleware"
                           :href "http://www.compojure.org/docs/middleware"}]}
                 {:title"Clojars"
                  :links [{:text "Clutch"
                           :href "http://clojars.org/org.clojars.ato/clutch"}
                          {:text "JOGL2"
                           :href "http://clojars.org/jogl2"}]}
                 {:title "Enlive"
                  :links [{:text "Getting Started"
                           :href "http://wiki.github.com/cgrand/enlive/getting-started"}
                          {:text "Syntax"
                           :href "http://enlive.cgrand.net/syntax.html"}]}]})
</pre>

This of course normally be something that would have a read out of a database. The take away here is Clojure makes it easy to define nested data structures. *dummy-context* is just a hash-map (aka dictionary, aka associative array) of two key-value pairs. The first pair is for the title of the page. The second pair is the list of sections. Each section also has a title as well as a list of link. Each link has some text and url. If you're used to building up JSON data structures from databse results this should pretty familiar to you.

h3. Figuring out your selectors

Using Enlive for templating usually involve two steps. The first step is figuring out which part of the markup you want to make into a component. Each component will become a snippet. A snippet is reusable mini-template that you can use when constructing larger templates. In order to create a working snippet you need to determine the CSS selector which will allow you to match exactly that part of the document.

Consider our situation. Our designer has handed us some nice markup and some CSS. To better convey the final result they have included dummy content. With a traditional templating solution this is a big nono. With Enlive, working around it requires a minimal amount of effort. So the key here is to identify the "model" element.

In our case we have two distinct models, the first is the pair of the section title and the links for that section. The second is the individual link. In a templating laguage we would probably do something like this:

<pre>
{% for section in sections %}
<h2 class="title">{{ section.title }}</h2>
<ul class="content">
 {% for link in section.links %} <!-- Inner Loop -->
 <a target="new" href="{{ link.href }}">{{ link.text }}</a>
 {% endfor %}
</ul>
{% endfor %}
</pre>

First, we want to be able handle the inner loop. On one level, as you're about see, there's a little more typing involved upfront when using Enlive. But you will end up with something that's considerably more reusable. In the traditional template the inner link loop and the outer section loop are hopelessly interwined. You may have many pages on your site that use the same section pattern but not the internal link pattern. But since these can't be separated you'll have to do some copy and paste. Not so with Enlive.

So let's define our link component. We don't want the dummy content so we really only want to match the very first link that satisfies our need, the selector looks something like this:

<pre>
(def *link-sel* (html/selector [[:.content (nth-of-type 1)] :> html/first-child]))
</pre>

We only want to match only the first ul element that we find that has the links class and only the very child inside that. This is the selector that gets the job done. It's analagous to:

<pre>
.content:nth-of-type(1) > *:first-child
</pre>

It's important to note that using *nth-of-type* requires an extra pair of brackets around the element *ul*. This extra pair of brackets is easy to forget. Whenever you want to be more specfic about what type of tag you want to match (beyond matching on CSS id or class) you'll need an extra pair of brackets.

Now that we have our selector *defsnippet* will look like the following (don't forget that *html* is just an alias for *net.cgrand.enlive-html*):

<pre>
(html/defsnippet link-model "tutorial/template2.html" *link-sel*
  [{text :text href :href}] 
  [:a] (html/do-> 
        (html/content text) 
        (html/set-attr :href href)))
</pre>

Snippets are like templates with two main differences. First, snippets take a selector. This means that they can match only specific parts of an HTML document. The function produced by a *defsnippet* returns transformed content, <i>not</i> a list of strings the way *deftemplate* does. This snippet destructures it's first argument (a hash-map) to extract the value of the keys *:text* and *:href*. We're also introduced to *html/do->*. This is a convenience, we often want to take the matched element and apply a series of transformations on it. In this case we want to set the content of the node as well as it's href attribute.

Let's try out our snippet to see that it worked:

<pre class="console">
tutorial.template2> (render (emit* (link-model {:href "bar" :text "foo"})))
</pre>

Here we have to use emit* because snippets return a sequenes of nodes not strings the way templates do. *render* is just a utility function for taking a number of strings and creating a single string.

Okay now we want to loop over the sections. A section is a *h2* tag followed by a *ul* tag. Again we need to figure out the correct selector. This time we're trying to emulate the following popular pattern for the outer loop:

<pre>
{% for section in sections %} <!-- OUTER LOOP -->
<h2>{{ section.title }}</h2>
<ul>
  {% for link in section.links %}
  <a target="new" href="{{ link.href }}>{{ x.text }}</a>
  {% endfor %}
</ul>
{% endfor %}
</pre>

Note that unlike the previous example what we're looping over has no "container". That is, there is no surrouding element for the adjacent *h2* and *ul* tags. Enlive recently added support for "ranges" making it simple to express this pattern with Enlive templates.

Again our HTML has some dummy content again. We only care about the first range of *h2* and *ul* tags, we don't want to match any more than that. We can define a selector to do this like so:

<pre>
(def *section-sel* (selector {[:.title] [[:.content (nth-of-type 1)]]}))
</pre>

There no CSS selector that can represent this. Again take care to note that since we want to select only the first *ul* that we find we need an extra pair of brackets around :ul. This is a common mistake to leave these out.

Now that we have our selector we can define our section snippet like so. Pretty straightforward. Remember *defsnippet* just creates a function which can take whichever arguments you specify and returns the transformed markup. We're simply creating links using *link-model* and putting those links inside of the *ul* in the section.

<pre>
(defsnippet section-model "tutorial/template2.html" *section-sel*
  [{:keys [title data]} model]
  [:.title]   (content title)
  [:.content] (content (map model data)))
</pre>

Now let's at the template to see how we put this all together:

<pre>
(html/deftemplate index "tutorial/template2.html"
  [{:keys [title sections]}]
  [:#title] (html/content title)
  [:body]   (html/content (map #(section-model % link-model) sections)))
</pre>

As you can see it looks really similar to *section-model*. Again the main difference is that templates don't take selectors and the function they define returns a list of string.

Thus while we've seen some interesting features and HTML/code seperation is cool, Enlive seems like it involves <i>more</i> work then it actually saves. That's because we're showing a very trival example. In the third example we'll show just how much time Enlive can save you when building a less trivial example.

h2. Your Third Template - Template Inheritance

We now have a basic working idea of how templates work in Enlive. Template are simply functions. Following a well-known pattern it's best to pass a single map to the template allowing the template to be easily changed over time as your requirementes grow. Now it's still unclear if there any real advantages to the Enlive way. Hopefully in this tutorial we can prove it's immense power.

Start a REPL if you don't already have one running with *lein repl*. Type the following:

<pre class="console">
tutorial.template2=> (stop-app)
nil
tutorial.template2=> (ns tutorial.template3)
nil
tutorial.template3=> (load "template3")
nil
tutorial.template3=> (start-app)
</pre>

Point your favorite web brower to *http://localhost:8080/base.html*. You should see a fairly plain page. This is not a template. You can try opening up base.html as file with your browser and see that it's identical. Now point your browser at *http://localhost:8080/3col.html*. You should see another page that has a 3 column layout. Now point your browser at *http://localhost:8080/a/*. The code required to do this follows:

<pre>
(defn viewa [params session]
  (base {:title "View A"
         :main (three-col {})}))
</pre>

If you look at the markup for *base.html* and *3col.html* you will see that there is not one line of code! So how did we magically put these two things together with so little code! Once understand the what's going, the whole concept of template inheritance is completely boring. 

In Enlive, constructing pages is simply putting some functions together!

Take a look at *http://localhost:8080/navs.html*. You should see some truly ugly nav bars ;) Now point your browser at *http://locahost:8080/b/. You can see it's easy for to define a site wide layout, a 3 column middle main layout, and customize the contents of each column. Again there's absolute no code in the markup, only the following code is needed to construct this page:

<pre>
(defn viewb [params session]
  (let [nav1 (nav1)
        nav2 (nav2)]
   (base {:title "View B"
          :main (three-col {:left  nav1
                            :right nav2})})))
</pre>

Pretty slick. Templating with Enlive is just write Clojure code. This very different from even the good HTML templating solutions out there- very few give you the full power of the language.

One last live example before we dive into the code. Point your browser at *http://localhost:8080/c/*. Huh, looks pretty much like b. Point your browser at *http://localhost:8080/c/reverse*. Notice something different?

We just flipped the two navs! How complicated is doing something like this?

<pre>
(defn viewc [params session]
  (let [navs [(nav1) (nav2)]
        [nav1 nav2] (if (= (:action params) "reverse") (reverse navs) navs)]
    (base {:title "View C"
           :main (three-col {:left  nav1
                             :right nav2})})))
</pre>

We added one, yes, <i>one</i> more line of code.

So how does this actually work? Open up *template3.clj* in your favorite text editor.

h3. The Templates and Snippets

The first thing to look at is the *base* template.

<pre>
(html/deftemplate base "tutorial/base.html"
  [{:keys [title header main footer]}]
  [:#title]      (maybe-content title)
  [:#header]     (maybe-substitute header)
  [:#main]       (maybe-substitute main)
  [:#footer]     (maybe-substitute footer))
</pre>

First thing, *maybe-content* and *maybe-substitute* are not Enlive functions. They are two simple macros. *maybe-content* will only set the content of its node if its argument is not nil. *maybe-substitute* will only substitute its node if its argument is not nil.

Why would we do this? This because want to be able to handle template inheritance. That is base represents the most basic template. We can then "inherit" from this template overriding only specific elements of this base template. Note that this template uses *base.html*. You should look at this file now.

Next is the *three-col* col snippet. It should be pretty obvious that this is a snippet for doing three column layout. Note that it uses *3co.html*, you should take a look at this file.

The last bits are the various nav snippets and they are loaded *navs.html*. Again you should gover this file.

h3. The Pages

Now for the fun part. The pages are just functions now more no less. The first page *viewa* is just rendering the base template with the title "View A" and setting the main block of the page to the 3 column snippet.

The page *viewb* does pretty much the same thing but this time we've add some navs for flair. Notice how much this function looks like *viewb*. Template inheritance is just function composition.

*viewc* does pretty much the same thing but it checks to see if there is a parameter for reversing the navs. If present, the order of the navs is reversed.

It should be far more clear now what Enlive brings to the table over traditional templating solutions. While preparing your templates and snippets take a little more work up front, building different pages from these templates and snippets is very, very fast and making changes is just moving a couple of values around in your functions, not mucking around with a broken DSL.

h2. Common Mistakes & Caveats

h3. Converting Numbers

When outputting numbers you need to convert them with *str*.

<pre>
[:div.foobar] (content (str 1))
</pre>

Since snippets take a selector sometimes you might not have set this value correctly. This is usually the case if you're not seeing any output at all from a snippet. It's really easy to test a snippet - remember they're just functions.

h3. Template out of date

Your templates do not automatically reload. When you make edits to your HTML or your template code I recommend running the following at the REPL:

<pre>
(load "your-library-name")
</pre>

It's a minor annoyance for all the benefits you reap. It also wouldn't be too hard to create a system that reloaded tempaltes (at least while in development mode) upon page refresh.

Be careful, *do not include the .clj extension*. Also *do not use -'s in your file name*. If you want dashes you need to name with actual file using underscores.
