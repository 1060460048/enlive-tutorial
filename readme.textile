h1. Under Construction

If somehow you happen to stumble upon this tutorail, please note that it not even close to being complete. Proceed at your own peril.

h1. An Introduction to Enlive

Enlive has been around for sometime now, yet the Clojure community has been slow to embrace this useful library. I believe this is due simply to the lack of good introductory documentation. This is no slam against Christophe Grand. He's a busy man and I rather he write up more excellent tutorials on how to optimize Clojure code to blazingly fast speed than create introductory tutorials about Enlive. In anycase that's what open source communities are all about, right? Contribution!

h2. What You need to Know

Not much. This tutorial is intended even for developers who have little or no exposure to Clojure. At the very least you'll need to have the Java Virtual Machine (JVM) installed. If you do know Clojure the tutorials are fairly amenable to skimming.

h2. Why Enlive?

Enlive presents a dramatically different approach to generating HTML then what's out there.

** It entirely eliminates the need to mix code/markup.
** Use CSS like syntax to manipulate HTML.
** Template inheritance isn't some fancy trick, it just plain old function composition.
** You access to the full power of Clojure to manipulate your templates (macros!).

One good analogy might be "XSLT that doesn't suck".

h2. What We'll Cover

There are 6 examples. 

The first one covers grabbing the headlines and points from Hackers News. The next one shows how to make the code less redundant. And the third scrapes the New York Times front page since that presents far more challenges than Hacker News.

The 4th example shows how to use Compojure and Enlive together. The 5th example shows that Enlive can do much of the fancy template inheritance magic you might be used to coming from Django or some other popular modern webframework.

The final tutorial is fairly advanced. It illustrates how Clojure, being a Lisp, can in fact template itself! I use this ability to illustrate how a downside to Enlive can be overcome. For example, you'll often have a widget whose elements you might just want replace by CSS id (or class). Enlive syntax makes this somehwat tedious for this simple, though common, case. With macros you can achieve the same level of simplicity even though it is not a feature that ships with Enlive!

h2. Clone This Repo

The usual:

<pre class="console">
git clone git://github.com/swannodette/enlive-tutorial.git
</pre>

h2. Install Leiningen

In order to start playing around as fast possible you should use Leiningen. Leiningen is the easy_install (Python) and gems (Ruby) of the Clojure world. Phil Hagelberg and Co. have done a considerable amount of excellent work to make dependency management simple. And I truly envy the new Clojurians who don't know the times before *lien repl* and *lein swank* :)

Once you have Leiningen installed, switch into this repository's source directory. From there run the following command:

<pre class="console">
lein deps
</pre>

This will install all of the dependencies. This make take a second and will probably generate a lot of ouptut. Once the the dependencies are installed enter the following command into your terminal:

<pre class="console">
lein repl
</per>

This will launch a Clojure REPL (Read-Eval-Print-Loop) that has the classpath set properly. Be very thankful if you're not even sure what the last sentence means.  Leiningen removes one of the most tedious things about dealing with the JVM - maintaining the classpath.

h2. Your First Scrape with Enlive

Enlive isn't just good for websites, it's also fantastic for scraping the content of webpages. It allows you to scrape content by using a syntax very similar to CSS3 (plus some even cooler goodies). In the REPL type the following lines (note that => is the prompt):

<pre class="console">
=> (use 'tutorial.scrape1)
nil
=> *base-url*
"http://news.ycombinator.com/"
</pre>

We just loaded the first tutorial into the REPL. Let's see what in that file. Open up scrape1.clj (you can find it in repo/src/tutorial/). You'll see it's a fairly short program. 

At the top of this file is the namespace declaration. This keeps your code from clashing with other people when they try to use your library. The namespace declaration also includes another library, Enlive, via require. In this case generating an alias so we don't have to type the very long namespace for Enlive.

The function *fetch-url* grabs the contexts of a url synchronously. *fetch-url* uses *html/html-resource* (remember we alias *net.cgrand.enlive-html* to html for convenience) another handy function defined in the Enlive library. It takes raw HTML and converts into anested data structure. 

Note that the function *hn-headlines* uses this *fetch-url*. But it's also surrounded by a lot of funny stuff.

Note the Enlive function *html/select*. *html/select* takes parsed html content and select the nodes specified by a Clojure Vector that looks very similar to a CSS3 selector. 

<pre>
[:td.title a]
</pre>

Now that looks kind of weird. But if you squint a little bit it might remind you a little bit of this:

<pre>
td.title a
</pre>

This is a CSS selector for matching all links inside of table elements that have the CSS class "title".

Believe it or not, these 10 lines of code are enough to extract all of the headline title from the Hacker News front page. Let's try it out at the REPL now.

<pre>
=> (hn-headlines)
("A 'lorem ipsum' for images." "Google Reader Can Now Track Changes to Any Website - Even Without a Feed" "jQuery 1.4.1 Released" ... "More")
</pre>

Nice. After this the next function *hn-points* should make a lot more sense. It does the same thing but we grab the score from a different place in the markup. Try to run this function as well.

<pre>
=> (hn-points)
... output ..
</pre>

The last function takes the output of the two different functions and prints out the headline and score for each item on Hackers News. 

<pre>
=> (hn-headlines-and-points)
... output ..
</pre>

Not bad for 17 lines of code. One obvious problem here is that we make two requests for the Hacker News front page. Let's fix this now.

h2. Your Second Scrape

Take a look at scrape2.clj. It looks pretty much the same except that we not longer have one function to grab headlines and another for article points.

<pre>
(defn hn-headlines-and-points []
  (map html/text
       (html/select (fetch-url *base-url*)
                    #{[:td.title :a] [:td.subtext first-child]})))
</pre>

This select grabs what we're interested at the same time.

<pre>
#{[:td.title :a] [:td.subtext first-child]}
</pre>

Is pretty much the same as

<pre>
td.title a, td.subtext:first-child
</pre>

Let try out the functions. Start up the repl with *lein repl* if you've shut it down and run the following.

<pre class="console">
=> (use 'tutorial.scrape2)
nil
=> (hn-headliens-and-points)
... output ...
</pre>

The results are interleaved, so we can use Clojure's partition function to pair them up and output them just like we did in the previous scrape.

h2. Your Third Scrape

By now you should feel like a pro. The third one, scrape3.clj tackles something considerably more difficult. Now to be clear this not that useful since the New York Times provides a fairly comprehensive list of RSS feeds. But the structure of the New Yorks Times page forces us to think about how to best leverage Enlive's abilities.

h2. You First Template

This is where things begin to get really interesting. We're going to use Compojure, and ultralight http framework. If you're familiar with Rack or CherryPy you will feel right at home.

h2. Common Mistakes

When outputting numbers you need to convert them with *str*.

<pre>
[:div.foobar] (content (str 1))
</pre>

Since snippets take a selector sometimes you might not have set this value correctly. This is usually the case if you're not seeing any output at all from a snippet. It's really easy to test a snippet - remember they're just functions.

h2. Macroology

Now that you understand how to template with Enlive there's something to consider. Enlive does not work by manipulating text, it actually manipuates structure. While this comes back in spades when you're actually constructing pages this does unfortunately make the simple case unweildy.

Enlive for example doesn't really let you create templates from a string of markup. The following is invalid:

<pre>
(deftemplate foo "<span id='foo'></span>"
  [ctxt]
  [:#foo] (content (:foo ctxt)))
</pre>

In order to do that you need to hand an the string as an InputStream to *deftemplate*. You can do that like so:

<pre>
(use 'net.cgrand.enlive-html)
(import '[java.io ByteArrayInputStream])
(defn to-in-stream [str] (ByteArrayInputStream. (.getBytes str "UTF-8")))
</pre>

Now you have a nice function to convert strings into InputStreams. You can now define the template like this:

<pre>
(deftemplate foo (to-in-stream "<span id='foo'></span>")
  [ctxt]
  [:#foo] (content (:foo ctxt)))
</pre>

But really that is kind of annoying. The simple case is just a lot worse then what other templating solutions provide. Can this be made any better?

Well this is Lisp after all!

One of the most powerful tools you have at your disposal are macros. Now these are something you should attempt to use anywhere, but they can be quite useful when you just know that the code could better.

In a ideal for the simplest case we would like something like the following:

<pre>
(templ simple "<span id='foo'></span><span id='bar'></span>")
(simple {:foo "Hello ", :bar "world!"})
</pre>

Can we have our cake and eat it to.

The following is somewhat advanced and most likely make the most if you have at least some passing familiarity with macros.

Macro allow to you create templates for your code. The main difference between 